
class Node:
    def __init__(self, point, left_child=None, right_child=None):
        self.point = point
        self.left_child = left_child
        self.right_child = right_child

def build_tree(points, depth=0):
    
    # Base case
    if not points:
        return None
    
    k = len(points[0]) # Dimensionality of the points.  2 for 2D , 3 for 3D, etc. 

    # The dimensional axis by which we will sort the points list. To keep the tree balanced, this
    # axis changes with every recursive call. For 2 dimensional points, this means the
    # dividing line is vertical, cutting the X axis in half first, then horizontal, dividing
    # the Y axis next, then back to X and so on
    axis = depth % k

    # Sort the points list by the coordinate at the given axis
    # TimSort TC O(n log n)
    points.sort(key=lambda point: point[axis]) 

    median = len(points) // 2  # This is where we will split the points list

    # Recursively call build tree function. In so doing, we create a new node from the point in the
    # middle of the list.  Its left and right children are generated by subdividing the different sides
    # of the list further using alternating axes.
    return Node(
        point=points[median],
        left_child=build_tree(points[:median], depth+1),
        right_child=build_tree(points[median+1:], depth+1)
    )


mp = points = [(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2)]
point_1 = mp[0]
point_2 = mp[1]

mz = zip(point_1, point_2)



def distance_squared(point_1, point_2):
    grouped_coords = zip(point_1, point_2) # Results in (X, X), (Y, Y)
    print(sum((x - y)**2 for x, y in grouped_coords))
    return 





#kd_tree = build_tree(mp)